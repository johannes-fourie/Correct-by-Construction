% Chapter Template

\chapter{Agile and Correct by Construction} % Main chapter title

\label{Chapter 2} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
\section{Correct by Construction development workflow}

The main properties of the CbyC development process are  \parencite{Tokeneer}:
\begin{itemize}
	\item each life-cycle phase can be validated;
	\item the semantic gap between life-cycle phases are reduced, making it possible
		to show the conformance of later life-cycle phases with earlier phases.
\end{itemize}

The CbyC development process products are shown in Figure \ref{fig:CbyCDev}. We now describe each product and how it is created.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{Figures/CbyC_process.pdf}
	\decoRule
	\caption{CbyC development process products.}
	\label{fig:CbyCDev}
\end{figure}

\subsection{System Requirements Specification}

The ``System Requirements Specification'' development process product is the result
of the requirements analysis process.

The aim of requirements analysis is to identify the needs of the stakeholders, 
the desired behaviour of the system, and any non-behavioural characteristics that are needed \parencite{Tokeneer}. 

Requirements management extends throughout the system's development, but it is 
most significant at the beginning, where it is used to identify \parencite{Tokeneer}:
\begin{itemize}
	\item the stakeholders, who have an interest in the development and use of the system
	\item the system boundary, to clarify the scope of the project and the interfaces to external systems
	\item the expected use, in terms of interactions between users and the system
	\item system properties, such as security properties, performance properties, etc.
\end{itemize}

Every requirement should be traceable through each level of system representation (requirements, specification, design, code, test) \parencite{Tokeneer}.

The reasons for producing the System Requirements Specification are \parencite{Tokeneer}:
\begin{itemize}
	\item To early in the project clarify the system's boundary (what is in scope 
		and what is out of scope, and the interfaces necessary to external systems).
	\item To agree on the system requirements with all of the stakeholders.
	\item To document the requirements in a sufficiently precise manner to allow 
		subsequent development of the formal specification to proceed smoothly with 
		little customer input.
	\item To clarify and document the assumptions about the behaviour of external 
		systems, a common source of error.
	\item To identify and manage conflicting expectations between stakeholders.
\end{itemize}

\subsection{Formal Specification}

The aim of the Formal Specification is to unambiguously describe what the system
will do. It should enable the developer and the client to gain a common
understanding of what the system will do \parencite{Tokeneer}.

The abstraction level is important. The formal specification should not address 
how the system is implemented, internal details are deliberately left very abstract. 
Interactions with the external environment are specified, but may be left abstract \parencite{Tokeneer}.

The Formal Specification is written in mathematical notation with an English 
narrative. The specification is divided into small components that can be reasoned
about individually and then combined to describe the system as a whole \parencite{Tokeneer}.

The reasons for producing a Formal Specification are \parencite{Tokeneer}:
\begin{itemize}
	\item It provides an unambiguous description of what the system does. This is
		important for gaining client approval of the behaviour of the system to be
		developed.
	\item It is demonstrably complete.
	\item It can be formal verified, i.e. it can be proved consistent.
\end{itemize}

\subsection{Formal Design}

The aim of the formal design is to elaborate the abstract aspects of the Formal 
Specification to explain how the system will be implemented. The Formal Design 
describes the system in terms of concrete state and operations using types that
are easily implemented. The Formal Design is the source of the required functional
behaviour used during implementation  \parencite{Tokeneer}.

The design is written in the same mathematical notation as the Formal Specification.
This means that the design can be formally verified and errors can be uncovered
before implementation starts \parencite{Tokeneer}.

The reasons for producing a Formal Design are  \parencite{Tokeneer}:
\begin{itemize}
	\item It provides an unambiguous description of how the system does what the formal specification requires.
	\item It can be shown to be complete.
	\item It can be formal verified, i.e. it can be proved consistent.
\end{itemize}

\subsection{System Test Specification}

The aim of the System Test it to demonstrate that the system has the correct 
behaviour as specified in the Formal Specification. This differs from the goals of
acceptance testing which is designed to demonstrate that the System meets
its requirements. System Testing aims to achieve 100\% coverage of the formal 
specification. Thus so all possible behaviours described in the formal specification
should be exercised at least once \parencite{Tokeneer}.

The Formal Design is a refinement of the Formal Specification. Therefore the Test
Specification can also be written against the Formal Design if you want to tests 
details of the design \parencite{Tokeneer}.

All System tests are specified in a System Test Specification prior to their 
execution.  The tests are specified as scenarios that might occur in typical usage
of the system. The specification includes documentation of the expected outcome
of the test. System test specifications also traces each test to the components
of the Formal Specification/Design that the test attempts to exercise \parencite{Tokeneer}.

Where code coverage metrics need to be captured, this is be done during the
System test. This allows us to question the use of any code that cannot be covered
by a system test. If the code is valid then focused unit tests should be added to
cover the code \parencite{Tokeneer}.

The reasons for producing a System Test Specification are \parencite{Tokeneer}:
\begin{itemize}
	\item A system test focuses on testing the behaviour of the whole system against
		the expected (specified) behaviour.
	\item A system test is likely to find faults caused by the incorrect interaction
		of modules within the system.
	\item System testing complements static analysis, in that it confirms the 
		dynamic behaviour.
\end{itemize}

\subsection{INFORMED Design}
CbyC design methodology is based on information flow. The information flow is 
defined using a contract-based notation. The contract-based notation is used to
define the abstract state of the program and the information relationships across
boundaries \parencite{CbyCMan}.

Consideration of information flows at the design stage leads to programs with the
desirable properties of abstraction, encapsulation, high cohesion and loose 
coupling \parencite{Tokeneer}.

The \textbf{IN}formation \textbf{F}low \textbf{OR}iented \textbf{ME}thod of
object \textbf{D}esign (INFORMED) design provided an architectural framework
in which to perform the implementation. Consideration of information flows at the
design stage results in programs with the desirable properties of abstraction, 
encapsulation, high cohesion and loose coupling \parencite{Tokeneer}.

The INFORMED design aids maintenance and upgrades of the software by providing a
route-map from the Formal Design to the code \parencite{Tokeneer}.

The reasons for producing an INFORMED Design are \parencite{Tokeneer}:
\begin{itemize}
	\item It focuses on the system architecture and ensures that the architecture 
		fits the information flow model.
	\item It provides the mapping from the Formal Design to the Code before writing
		the code.
	\item It complements the Formal Design without duplicating functional information.
\end{itemize}

\subsection{Code Implementation}
We start by writing the module specification. The specification is the public 
interface and the contracts governing the global state of the module. The contacts
specify how inputs are allowed to influence outputs \parencite{Tokeneer}. 

After writing the specification we implement the module body. The Formal Design is
detailed enough to make that the mapping from the design to the code simple 
\parencite{Tokeneer}.

Modules providing infrastructure are developed early. Module are implementation 
in a order that allows system level functionality to be added incrementally. This
means that a basic system can be built as soon as possible and functionality is 
added in subsequent builds. This has the advantage of addressing code integration
risks as early as possible \parencite{Tokeneer}.

By using languages that allows static analysis we can evaluate the code 
contracts at build time. Thus if the code builds it is correct as specified by the
contracts \parencite{Tokeneer}.

\section{Agile Software Development}

\subsection{Manifesto for Agile Software Development}

The manifesto sets out the overarching principles of agile software development \parencite{Beck2001ManifestoFA}:

\begin{displayquote}
We are uncovering better ways of developing software by doing it and helping 
others do it. Through this work we have come to value:

\begin{itemize}
	\item \textbf{Individuals and interactions} \textit{over} processes and tools 
	\item \textbf{Working software} \textit{over} comprehensive documentation 
	\item \textbf{Customer collaboration} \textit{over} contract negotiation 
	\item \textbf{Responding to change} \textit{over} following a plan 
\end{itemize}

That is, while there is value in the items on the right, we value the items on
the left more.
\end{displayquote}

\subsection{Agile Software Development using Scrum}
Scrum is an agile project management methodology. It focuses on short feedback
loops all development process. The client is involved in all iterations of the process
ensuring that the completed project meets the client's needs and expectations \parencite{ScrumGoesFormal}.

\subsubsection{Scrum roles}
There are three roles in Scrum \parencite{ScrumGoesFormal}:
\begin{description}
	\item [Product Owner:] This person represents the customer’s interest, and 
		determines the goal of each iteration. It is the product owner's responsibility
		to prioritise the different tasks ensuring that the most important functionality
		is implemented first.
	\item [Scrum Master:] It is the Scrum Master's responsibility to facilitate the Scrum 
		process and protect the agile principles. He also needs to protect the team by
		removing any impediments encountered by the team, ensuring that the team is not
		distracted from the task at hand.
	\item [Team:] A team consists of five to nine people working together to create
		a functional system which satisfies the user needs. The team consists of people
		with a broad set of competences so that the team is self-organised and contained.
\end{description}

\subsubsection{Activities and Artifacts}
Scrum has several activities, that describe the development workflow, and artifacts,
that are produced by the process \parencite{ScrumGoesFormal}:
\begin{description}
	\item [Product vision:] This is the initial idea phase. The vision of the 
		product is defined during this process.
	\item [Product backlog:] This is a prioritised list of artifacts that are needed
		in the product. The artifacts are described as user stories, the story describes
		how we are adding value for the user.
	\item [Sprint:] This is the development iteration. Sprints are time boxed between
		 two to six weeks.
	\item [Sprint planning:] The first day of each sprint is used to plan what is
		going to be done during the sprint.
	\item [Sprint backlog:] These are the stories, from the product backlog the team
		has committed to implementing in the sprint.
	\item [Daily Scrum meeting:] This is a short, 15 minutes, daily meeting used to plan
		the days work and checking on the state of the stories in the sprint.
	\item [Sprint review:] The meeting is held at the end of the sprint to show the 
		product owner the work that has been completed during the sprint.
	\item [Sprint retrospective:] This meeting is held after the sprint review. The 
		focus of the meeting is not on the work completed during the. The purpose
		of the meeting is to discuss the people, relationships, processes, and tools 
		in order to improve the team's effectiveness.
\end{description}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{Figures/Scrum_workflow.pdf}
	\decoRule
	\caption{The scrum workflow.}
	\label{fig:ScrumWorkflow}
\end{figure}

\section{Using CbyC in Agile Scrum}

The strived for characteristic of agile software development is the ability to 
react to change. With scrum we will have to implement the change in order to test
it. If we evaluate this against the Agile manifesto:
\begin{description}
	\item [Responding to change:]  In order to evaluate a change: a story has to be
		create, and the story has to be refined and sized. Then, depending on the 
		priority, existing work has to be moved to make resources available to implement
		the change. 
	\item [Working software:] We have to implement the requested change in order to
		validate it. If the change does not work we might end up with invalid or
		non-functional software.
	\item [Customer collaboration] For a change to be actioned the team will reason
		through it on a whiteboard. This reasoning is based on opinion and results in
		arguments that cannot be resolved without implementing the change.
\end{description}

If we now augment our agile scrum workflow with CbyC the process changes as shown in  Figure \ref{fig:ScrumCbyCWorkflow}.

\subsubsection{Roles}
\begin{description}
	\item [Team Architect:] This is the person who helps the Product Owner create 
		the formal specification. This role can be shared amongst the team members and 
		does not have to belong to a specific person.
\end{description}

\subsubsection{Activities and Artifacts}
\begin{description}
	\item [Product Vision:] Here the Team Architect incorporates the Product Owner's
		requirements into the Formal Specification. The Formal Specification is then 
		validated. If the requirements are valid stories are created on the Product
		Backlog.
\end{description}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{Figures/Scrum_CbyC_workflow.pdf}
	\decoRule
	\caption{The scrum with CbyC workflow.}
	\label{fig:ScrumCbyCWorkflow}
\end{figure}






