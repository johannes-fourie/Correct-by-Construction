% Chapter Template

\chapter{Correct by Construction (CbyC) } % Main chapter title

\label{Chapter 1} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
\section{Overview}

A lot of time and money is lost dealing with the consequences of software bugs. 
The ''Correct by Construction'' software development methodology proposes to limit
software bug by:  
\begin{enumerate}
	\item making it difficult to introduce errors, and
	\item detecting and removing errors as early as possible.
\end{enumerate}

To achieve this we apply the following strategies \parencite{CbyCMan}:
\begin{itemize}
	\item use formal notation for deliverables;
	\item use tool-supported methods to validate deliverables;
	\item carry out small steps and validate the deliverables for each step;
	\item sate things only once;
	\item design software that is easy to validate;
	\item do the hard things first.
\end{itemize} 

Software development can be divided in to two parts: specification and design; 
and implementation. To make this applicable to my work environment I chose to use
TLA+ as a specification language and C\# as a programming language.

%----------------------------------------------------------------------------------------
\section{Specification and Design}

Regular language is inherently imprecise. Writing a specification and design in 
regular language leaves the documents open to conflicting interpretations.

Using a mathematical, formal, language to define the specification and high-level
design of a system provides a precise description of the system's behaviour and
a precise model of its characteristics. Using a mathematical language also 
enables the use of automated tools to verify the specification and design \parencite{CbyCMan}.

Formal specifications and designs are more precise and this forces us to
understand issues and questions before we start coding \parencite{CbyCPraxis}.

\subsection{TLA\(^+\)}

TLA\(^+\) has a large community and is proven useful in industry 
\parencite{Industrial_Use_of_TLA}. TLA\(^+\) was created by Leslie Lamport in the
late 1980's. TLA (Temporal Logic of Actions) is a simple variant of Pnueli's 
temporal logic. Most TLA specifications consists of ordinary non-temporal 
mathematics. Temporal logic is only used when appropriate. TLA is written in an
assertional reasoning style \parencite{SpecifyingSystems}.

%----------------------------------------------------------------------------------------
\section{Implementation}

CbyC design methodology is based on information flow. The information flow is
defined using a contract-based notation. The contract-based notation is
used to define the abstract state of the program and the information relationships
across boundaries \parencite{CbyCMan}. 

CbyC suggests the generation of evidence of correctness by using programming
languages and tools, that allow for verification and analysis \parencite{CbyCMan}.

Testing is usually the main method of verification and validation. The normal testing
method follows these steps:
\begin{enumerate}
	\item test individual units; 
	\item integrate them and test the integration; 
	\item then test the system as a whole. 
\end{enumerate}
This approach is inefficient because unit testing is ineffective and expensive. 
Unit testing is ineffective because most errors are interface errors, not internal
errors in units. Unit testing is expensive because you have to build test 
harnesses to test units in isolation \parencite{CbyCPraxis}.

A more efficient and effective approach is to incrementally built the system from
the top down. Each build is a real (if small) system and the system can be completely 
exercised in a real environment. This reduces the integration risk \parencite{CbyCPraxis}.

\subsection{C\#}

\subsubsection{Design by contract}
CbyC program design is based on information flow expressed as code contracts 
\parencite{CbyCMan}. C\# does not have built in code contracts any more, but it
is very simple to implement code contracts using standard C\# language features.

\subsubsection{Property based testing}
C\# has very little static analysis tools able to mathematically prove correctness.
As an alternative we will use property based testing to exercise the code and show 
correctness \parencite{QuickCheck} \parencite{Hamlet94randomtesting}. We will be
using the FsCheck framework for our property based tests \parencite{FsCheck_home}.  
