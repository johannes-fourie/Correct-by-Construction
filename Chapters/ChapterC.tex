% Chapter Template

\chapter{C\#} % Main chapter title

\label{csharp} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\section{Code contracts}

Code contracts are an application of Hoare logic. Using Hoare logic
we can show that a program correctly implements a specification if, given a set of 
preconditions derived from the specification, the program never violates a set of
post conditions derived from the specification. We use the Hoare triple to 
represent the contract \parencite{BasisForProgramming}:

\[
	\{P\}Q\{R\}
\]

where:
\begin{description}
	\item [$P$] are the preconditions;
	\item [$Q$] is the program;
	\item [$R$] are the postconditions.
\end{description}

C\# does not have native support for code contracts any more \parencite{NoCodeContracts}. 
With some helper methods we can implement code contracts using standard C\# language
features. We are modelling our code contracts on the Design by Contract design 
\parencite{ObjectOrientedSoftwareConstruction}.

Design by Contract has two specification levels:
\begin{itemize}
	\item method preconditions and postconditions;
	\item class invariants.
\end{itemize}

Preconditions (require conditions) are a set of conditions that state what the method requires from 
the client (code calling the method) in order to function correctly.

Postconditions (ensure conditions) are a set of conditions that state what the method will ensure 
happens at the en of it's execution.

Class invents (invariant conditions) are a set of conditions that will always always be true after all 
executions.

We implement the contract condition tests using the below listed helper methods 
and classes.

\lstset{style=sharpc, caption={Implementing code contracts using helper methods and classes.}}
\begin{lstlisting}[frame=single]
public static class Contract
{
    public static Requirer Require(bool condition, string message)
    {
        if (!condition)
            throw new ConstactRequireException(message);
        else
            return new Requirer();
    }

    public static Ensurer Ensure(bool condition, string message)
    {
        if (!condition)
            throw new ConstactEnsureException(message);
        else
            return new Ensurer();
    }

    public static Invarianter Invariant(
	bool condition, string message)
    {
        if (!condition)
            throw new ConstactInvariantException(message);
        else
            return new Invarianter();
    }
}

public class Invarianter
{
    public Invarianter Invariant(bool condition, string message)
    {
        if (!condition)
            throw new ConstactEnsureException(message);
        else
            return this;
    }
}

public class Ensurer
{
    public Ensurer Ensure(bool condition, string message)
    {
        if (!condition)
            throw new ConstactEnsureException(message);
        else
            return this;
    }
}

public class Requirer
{
    public Requirer Require(bool condition, string message)
    {
        if (!condition)
            throw new ConstactRequireException(message);
        else
            return this;
    }
}
\end{lstlisting}

We can now write contracts using the helper methods and classes. 

Require conditions is the first code in the method. If we need to compare pre and 
post execution values we can create an anonymous object to store the old values. 
Only store value types and not reference types because the referenced values can
change and will not be preserved by the old object.

The class invariant conditions are listed in a method so that they can be executed
in all methods. 

Ensure and class invariant conditions are the last code in the method before it 
returns. 

\lstset{style=sharpc, caption={Writing  code contracts using helper methods and classes.}}
\begin{lstlisting}[frame=single]
public class Account
{
    private int _limit;

    public int Limit
    {
        get => _limit;
        set
        {
            Require(value > 0, "Limit must not be 0.");
            _limit = value;
            ClassInvariant();
        }
    }

    public int Total { get; private set; }

    public int Add(int value, int discount)
    {
        Require(value >= 0, "Value must be positive.")
            .Require(
                discount >= 0 && discount <= 50, 
                "Discount must be positive and not more than 50%");
        var old = new { Total };

        // method logic

        Ensure(Total > old.Total, "The total will not decrease.");
        ClassInvariant();
        return discountedValue;
    }
    
    private void ClassInvariant()
    {
        Invariant(Total >= 0, "The total will not be negative.")
            .Invariant(Limit > 0, "Limit will not be 0.");
    }
}
\end{lstlisting}


\section{Verification using Property Based Testing}
Because we don't have static analysis tools for C\# capable of verifying the code 
contracts we will be using property-based-testing to exercise the code and thereby 
verify the contracts.

We can represent a program or section of a program as a mathematical function
with all possible legal permutations of inputs seen as the function's domain and 
the output of the program the function's range.

It would be impractical to write unit tests that cover the complete input domain
of the program. Instead we write tests that take random points on the input domain
as input. We are not going to verify the outputs because if the outputs passes the 
contracts we assume the outputs are valid. This will eliminate the oracle problem 
\parencite{QuickCheck}.
 
When we tests smaller sections of the program separately random testing 
provides similar, adequate, code coverage as compared with determinisms testing
\parencite{QuickCheck}\parencite{Hamlet94randomtesting}.

We will be using FsCheck to create out property based tests. FsCheck is a .net 
implementation of QuickCheck \parencite{FsCheck_home}. 


